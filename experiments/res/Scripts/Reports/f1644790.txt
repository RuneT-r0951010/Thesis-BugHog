According to the CSP Level 2 Specification "If 'unsafe-inline' is not in the list" ... "Whenever the user agent would execute an inline script from an inline event handler, instead the user agent MUST NOT execute script, and MUST report a violation." https://www.w3.org/TR/CSP2/#allowed-script-sources however FireFox 62 and below followed the spec, but starting with FireFox 63 it ignores this restriction.
The change in the code that allowed this appears to be here:
https://searchfox.org/mozilla-central/diff/5fff1762ada26b04519cf8ed24489ca1b0f73c2f/dom/security/nsCSPContext.cpp#551-566
Given a CSP policy: default-src 'none';script-src 'sha256-vmevK1pwVutIOH96hxUOXymyXdR2hSlZRAu8QWiW3dw='; and the markup: <body onload="alert('attr');"> the hash matches: "alert('attr');" it will allow execution of the script. You can see an example of this in the test page: https://www.petefreitag.com/test/csp-hash-bug.html
Again, according to the CSP Level 2 spec it should only allow a valid hash or a valid nonce on "a script element". So, it should only allow it in the form: <script>alert('attr');</script> not in an inline event handler.
The CSP Level 3 spec added a CSP source list keyword 'unsafe-hashes' which provides a way to allow execution of inline script event handlers. A bug is already filed to track implementation of unsafe-hashes: https://bugzilla.mozilla.org/show_bug.cgi?id=1343950
It appears that the best way to fix this security issue would be to implement 'unsafe-hashes'. Anyone attempting to use a hash on an inline script event handler would find that it fails to execute in Chrome without adding 'unsafe-hashes', so I would not imagine any legitimate use cases would rely on the current behavior.